# Оптимизация БД для Shared Hosting (лимит 50 соединений)

## Проблема
Хостинг-провайдер ограничивает количество одновременных подключений к БД:
- **Лимит для пользователя БД**: 50 соединений
- **Проблемы**: Незавершающиеся процессы, превышение лимита, медленные запросы

## Реализованные оптимизации

### 1. Консервативные настройки пула соединений ✅
**Файл**: `lib/db.ts`

```typescript
connectionLimit: 2        // Максимум 2 соединения на процесс (было 3)
maxIdle: 1                // Автоматически закрывает лишние неактивные соединения
queueLimit: 10            // Ограничивает очередь запросов (вместо бесконечной)
idleTimeout: 300000       // 5 минут - автоматическое закрытие неактивных (было 30 минут)
connectTimeout: 10000      // 10 секунд на подключение
```

**Почему 2 соединения?**
- Учитываем несколько процессов: dev server, build, scripts
- При 2 соединениях на процесс × 10 процессов = 20 соединений (в пределах лимита 50)
- Оставляет запас для других процессов

### 2. Таймауты на запросы ✅
**Файл**: `lib/db.ts`

- Добавлена функция `executeQuery()` с таймаутом 30 секунд
- Автоматическое логирование зависших запросов
- Предотвращает накопление незавершающихся процессов

### 3. Автоматическое закрытие соединений ✅
**Файл**: `lib/db.ts`

- `idleTimeout: 300000` (5 минут) - неактивные соединения закрываются автоматически
- `maxIdle: 1` - максимум 1 неактивное соединение в пуле
- Обработка ошибок соединений с автоматическим удалением из пула

### 4. Обработка ошибок соединений ✅
**Файл**: `lib/db.ts`

- Автоматическое обнаружение критических ошибок (`ER_TOO_MANY_USER_CONNECTIONS`, `PROTOCOL_CONNECTION_LOST`)
- Соединения с ошибками автоматически удаляются из пула
- Логирование всех ошибок для диагностики

## Рекомендации по использованию

### ✅ Правильно (используется везде)
```typescript
const pool = getDbPool();
const [rows] = await pool.execute('SELECT * FROM users WHERE id = ?', [userId]);
// Соединение автоматически возвращается в пул после выполнения
```

### ❌ Неправильно (НЕ используется)
```typescript
const connection = await pool.getConnection();
// ... запросы ...
connection.release(); // Легко забыть!
```

### ✅ Для длительных операций
```typescript
import { executeQuery } from '@/lib/db';
const [rows] = await executeQuery('SELECT * FROM large_table', []);
// Автоматический таймаут 30 секунд
```

## Мониторинг

### 1. Через консоль сервера (development)
- Каждые 30 секунд выводятся статистики пула
- При каждом acquire/release выводятся логи
- Предупреждения при превышении 80% лимита

### 2. Через API endpoint
```bash
GET /api/admin/db-stats
```
Требует роль `superadmin`.

### 3. Через скрипты
```bash
# Проверить активные соединения
npm run check-db-connections

# Закрыть неиспользуемые соединения
npm run close-db-connections
```

## Что делать при превышении лимита

### Вариант 1: Подождать
- Неактивные соединения закроются автоматически через 5 минут
- Подождите 5-10 минут и попробуйте снова

### Вариант 2: Закрыть соединения вручную
```bash
npm run close-db-connections
```

### Вариант 3: Через панель хостинга
- Зайти в phpMyAdmin или панель управления БД
- Открыть "Processes" / "Процессы"
- Найти соединения пользователя `foldis00_padelo2`
- Закрыть старые/неиспользуемые соединения

### Вариант 4: Перезапустить сервер
```bash
# Остановить dev server (Ctrl+C)
# Подождать 1-2 минуты
# Запустить снова
npm run dev
```

## Оптимизация запросов

### ✅ Уже реализовано
1. **Batch запросы**: Вместо N запросов используется один с `IN (...)` 
   - Файл: `app/api/tournament/[id]/schedule/route.ts`
   
2. **Индексы**: Все таблицы имеют правильные индексы
   - `users`: `idx_email`, `idx_role`
   - `tournament_matches`: `idx_match_date`, `idx_group`
   - `sessions`: `idx_expires_at` (для автоматической очистки)

3. **Очистка сессий**: Автоматическая очистка истекших сессий
   - Файл: `lib/users.ts`

### ⚠️ Рекомендации для дальнейшей оптимизации

1. **Избегать N+1 запросов**
   - Всегда использовать JOIN или batch запросы
   - Пример: вместо `for (const match of matches) { await getPair(match.pair1_id) }`
   - Использовать: `SELECT * FROM pairs WHERE id IN (?, ?, ...)`

2. **Ограничивать результаты**
   - Всегда использовать `LIMIT` для больших выборок
   - Использовать пагинацию для списков

3. **Кэширование**
   - Кэшировать часто запрашиваемые данные (списки турниров, пользователей)
   - Использовать Next.js cache для статических данных

## Текущие настройки

```typescript
{
  connectionLimit: 2,        // Максимум 2 соединения
  maxIdle: 1,               // Максимум 1 неактивное
  queueLimit: 10,           // Очередь до 10 запросов
  idleTimeout: 300000,      // 5 минут
  connectTimeout: 10000,    // 10 секунд
  timeout: 30000,            // 30 секунд на запрос
}
```

## Проверка работоспособности

1. **Проверить текущие соединения:**
   ```bash
   npm run check-db-connections
   ```

2. **Проверить статистику пула:**
   - Открыть `/admin/db-monitor` (требует superadmin)
   - Или проверить логи сервера

3. **Мониторить в реальном времени:**
   - Следить за логами сервера
   - Проверять предупреждения о превышении 80% лимита

## Дополнительные рекомендации

1. **Production**: Рассмотреть увеличение лимита у хостинг-провайдера (обычно платно)
2. **Development**: Использовать локальную БД для разработки
3. **Monitoring**: Настроить алерты при превышении 80% лимита
4. **Logging**: Все ошибки БД логируются для анализа

